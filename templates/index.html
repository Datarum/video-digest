<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VideoDigest â€” YouTube è§†é¢‘æ€»ç»“</title>
<!-- Caveat: handwriting font for diagram nodes -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;600;700&display=swap" rel="stylesheet">
<!-- rough.js â€” Excalidraw-style hand-drawn rendering -->
<script src="https://cdn.jsdelivr.net/npm/roughjs@4/bundled/rough.js"></script>
<style>
:root {
  --bg: #f1f5f9;
  --surface: #ffffff;
  --primary: #6366f1;
  --primary-dark: #4f46e5;
  --primary-light: #eef2ff;
  --success: #22c55e;
  --success-light: #f0fdf4;
  --warning: #f59e0b;
  --warning-light: #fffbeb;
  --error: #ef4444;
  --error-light: #fef2f2;
  --text: #1e293b;
  --text-muted: #64748b;
  --border: #e2e8f0;
  --radius: 14px;
  --shadow: 0 1px 3px rgba(0,0,0,.08), 0 1px 2px rgba(0,0,0,.05);
  --shadow-lg: 0 8px 24px rgba(0,0,0,.10);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  padding: 24px 16px 64px;
}

/* â”€â”€ layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.container { max-width: 800px; margin: 0 auto; }

/* â”€â”€ header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 28px;
}
header .logo {
  width: 40px; height: 40px;
  background: var(--primary);
  border-radius: 10px;
  display: flex; align-items: center; justify-content: center;
  font-size: 20px;
}
header h1 { font-size: 22px; font-weight: 700; }
header p  { font-size: 13px; color: var(--text-muted); margin-top: 2px; }

/* â”€â”€ card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card {
  background: var(--surface);
  border-radius: var(--radius);
  padding: 24px;
  box-shadow: var(--shadow);
  margin-bottom: 16px;
}

/* â”€â”€ form â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.form-group { margin-bottom: 16px; }
label { display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px; color: var(--text-muted); }

input[type="text"], input[type="password"], select {
  width: 100%;
  padding: 10px 14px;
  border: 1.5px solid var(--border);
  border-radius: 8px;
  font-size: 15px;
  color: var(--text);
  background: var(--surface);
  transition: border-color .15s;
  outline: none;
}
input[type="text"]:focus,
input[type="password"]:focus,
select:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(99,102,241,.12); }

.url-input { font-size: 16px; padding: 12px 14px; }

.row { display: flex; gap: 12px; }
.row .form-group { flex: 1; }

.hint { font-size: 12px; color: var(--text-muted); margin-top: 5px; }

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 11px 24px;
  border-radius: 8px;
  font-size: 15px;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: opacity .15s, transform .1s;
}
.btn:active { transform: scale(.98); }
.btn-primary {
  background: var(--primary);
  color: #fff;
  width: 100%;
  font-size: 16px;
  padding: 13px;
}
.btn-primary:hover { background: var(--primary-dark); }
.btn-primary:disabled { opacity: .55; cursor: not-allowed; transform: none; }

/* â”€â”€ progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#progress-section { display: none; }

.steps { display: flex; flex-direction: column; gap: 0; }

.step {
  display: flex;
  align-items: flex-start;
  gap: 14px;
  padding: 12px 0;
  border-bottom: 1px solid var(--border);
  opacity: .4;
  transition: opacity .2s;
}
.step:last-child { border-bottom: none; }
.step.active, .step.done, .step.warn, .step.skip, .step.error { opacity: 1; }

.step-icon {
  width: 28px; height: 28px;
  border-radius: 50%;
  border: 2px solid var(--border);
  display: flex; align-items: center; justify-content: center;
  font-size: 13px;
  flex-shrink: 0;
  transition: background .2s, border-color .2s;
}
.step.active .step-icon  { border-color: var(--primary); background: var(--primary-light); color: var(--primary); animation: pulse 1.2s infinite; }
.step.done  .step-icon   { border-color: var(--success); background: var(--success-light); color: var(--success); }
.step.warn  .step-icon   { border-color: var(--warning); background: var(--warning-light); color: var(--warning); }
.step.skip  .step-icon   { border-color: var(--border);  background: var(--bg); color: var(--text-muted); }
.step.error .step-icon   { border-color: var(--error);   background: var(--error-light);   color: var(--error); }

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(99,102,241,.4); }
  50%       { box-shadow: 0 0 0 5px rgba(99,102,241,.0); }
}

.step-body { flex: 1; min-width: 0; }
.step-name { font-size: 14px; font-weight: 600; }
.step-msg  { font-size: 13px; color: var(--text-muted); margin-top: 2px; word-break: break-word; }

/* â”€â”€ results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#result-section { display: none; }

/* video header card */
.video-header {
  display: flex;
  gap: 16px;
  align-items: flex-start;
}
.video-thumb {
  width: 140px; height: 79px;
  border-radius: 8px;
  object-fit: cover;
  flex-shrink: 0;
  background: var(--bg);
}
.video-meta { flex: 1; min-width: 0; }
.video-title { font-size: 17px; font-weight: 700; line-height: 1.3; margin-bottom: 6px; }
.video-info  { font-size: 13px; color: var(--text-muted); display: flex; flex-wrap: wrap; gap: 10px; }
.video-info a { color: var(--primary); text-decoration: none; }
.video-info a:hover { text-decoration: underline; }

/* section label */
.section-label {
  font-size: 11px;
  font-weight: 700;
  letter-spacing: .08em;
  text-transform: uppercase;
  color: var(--text-muted);
  margin-bottom: 12px;
}

/* overview */
.overview-text { font-size: 15px; line-height: 1.7; color: var(--text); }

/* core structure diagram card header */
.diagram-card-hdr {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}
.diagram-card-hdr .section-label { margin-bottom: 0; }
.btn-expand {
  display: inline-flex; align-items: center; gap: 5px;
  background: none;
  border: 1.5px solid var(--border);
  border-radius: 6px;
  padding: 4px 12px;
  font-size: 12px;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  transition: background .15s, color .15s, border-color .15s;
}
.btn-expand:hover { background: var(--bg); color: var(--primary); border-color: var(--primary); }

/* core structure diagram â€” rough.js canvas */
.diagram-wrap {
  background: #fffdf5;
  border: 1.5px solid #e5dfc8;
  border-radius: 10px;
  padding: 20px;
  overflow-x: auto;
}
#res-diagram-canvas {
  display: block;
  width: 100%;
}

/* â”€â”€ diagram modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#diagram-modal {
  position: fixed;
  inset: 0;
  z-index: 1000;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.6);
}
#diagram-modal-bg {
  position: absolute;
  inset: 0;
}
#diagram-modal-inner {
  position: relative;
  background: #faf9f4;
  border-radius: 16px;
  width: calc(100vw - 48px);
  max-width: 1240px;
  height: calc(100vh - 64px);
  max-height: 920px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 24px 80px rgba(0,0,0,.35);
}
#diagram-modal-hdr {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  border-bottom: 1.5px solid #e5dfc8;
  flex-shrink: 0;
  background: #fefcf5;
}
#diagram-modal-hdr .modal-title { font-weight: 700; font-size: 14px; color: var(--text); }
#diagram-modal-hdr .modal-hint  { font-size: 12px; color: var(--text-muted); }
.modal-close {
  background: none; border: none; font-size: 20px; line-height: 1;
  cursor: pointer; color: var(--text-muted);
  padding: 4px 8px; border-radius: 6px;
}
.modal-close:hover { background: var(--bg); color: var(--text); }
#diagram-modal-body {
  flex: 1;
  min-height: 0;
  overflow: hidden;
  position: relative;
}
#diagram-modal-canvas {
  display: block;
  cursor: grab;
  touch-action: none;
}
#diagram-modal-canvas:active { cursor: grabbing; }
#diagram-modal-footer {
  padding: 6px 20px;
  font-size: 11px;
  color: var(--text-muted);
  background: #fefcf5;
  border-top: 1px solid #e5dfc8;
  flex-shrink: 0;
  text-align: center;
}

/* chapters */
.chapters { display: flex; flex-direction: column; gap: 16px; }

.chapter-card {
  border: 1.5px solid var(--border);
  border-radius: 10px;
  overflow: hidden;
  display: flex;
  gap: 0;
}
.chapter-frame {
  width: 140px;
  flex-shrink: 0;
  background: var(--bg);
  position: relative;
  overflow: hidden;
}
.chapter-frame img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}
.chapter-frame .no-frame {
  width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
  font-size: 26px;
  color: var(--border);
  min-height: 80px;
}
.chapter-body { flex: 1; padding: 14px 16px; min-width: 0; }
.chapter-ts {
  font-size: 11px; font-weight: 700;
  color: var(--primary);
  background: var(--primary-light);
  padding: 2px 8px; border-radius: 20px;
  display: inline-block;
  margin-bottom: 6px;
}
.chapter-title { font-size: 15px; font-weight: 700; margin-bottom: 5px; }
.chapter-summary { font-size: 13px; color: var(--text-muted); line-height: 1.6; }

/* action bar after result */
.action-bar {
  display: flex; gap: 10px; flex-wrap: wrap; margin-top: 16px;
}
.btn-outline {
  background: transparent;
  border: 1.5px solid var(--border);
  color: var(--text);
  padding: 9px 18px;
  font-size: 14px;
}
.btn-outline:hover { background: var(--bg); }

/* error box */
.error-box {
  display: none;
  background: var(--error-light);
  border: 1.5px solid #fca5a5;
  border-radius: 8px;
  padding: 14px 16px;
  font-size: 14px;
  color: var(--error);
  margin-top: 12px;
}
.error-box pre { font-size: 12px; margin-top: 8px; white-space: pre-wrap; color: var(--text-muted); }

/* responsive */
@media (max-width: 520px) {
  .row { flex-direction: column; gap: 0; }
  .video-header { flex-direction: column; }
  .video-thumb { width: 100%; height: 160px; }
  .chapter-card { flex-direction: column; }
  .chapter-frame { width: 100%; height: 120px; }
}
</style>
</head>
<body>
<div class="container">

  <!-- header -->
  <header>
    <div class="logo">ğŸ¬</div>
    <div>
      <h1>VideoDigest</h1>
      <p>è¾“å…¥ YouTube é“¾æ¥ï¼ŒAI è‡ªåŠ¨æ€»ç»“è§†é¢‘è¦ç‚¹ + æå–å…³é”®æˆªå›¾</p>
    </div>
  </header>

  <!-- input form -->
  <div class="card" id="form-card">
    <div class="form-group">
      <label>YouTube è§†é¢‘é“¾æ¥</label>
      <input id="url-input" class="url-input" type="text"
             placeholder="https://www.youtube.com/watch?v=..."
             autocomplete="off" spellcheck="false">
    </div>

    <div class="row">
      <div class="form-group">
        <label>è¾“å‡ºè¯­è¨€</label>
        <select id="lang-select">
          <option value="Chinese" selected>ä¸­æ–‡</option>
          <option value="English">English</option>
          <option value="Japanese">æ—¥æœ¬èª</option>
          <option value="Korean">í•œêµ­ì–´</option>
        </select>
      </div>
      <div class="form-group">
        <label>æœ€å¤§æˆªå›¾æ•°</label>
        <select id="frames-select">
          <option value="0">ä¸æˆªå›¾ï¼ˆçº¯æ–‡å­—ï¼‰</option>
          <option value="6">6 å¼ </option>
          <option value="12" selected>12 å¼ </option>
          <option value="20">20 å¼ </option>
        </select>
      </div>
    </div>

    {% if not server_has_key %}
    <div class="form-group" id="key-group">
      <label>Anthropic API Key</label>
      <input id="api-key-input" type="password" placeholder="sk-ant-...">
      <p class="hint">Key ä»…ç”¨äºæœ¬æ¬¡è¯·æ±‚ï¼Œä¸ä¼šè¢«ä¿å­˜ã€‚</p>
    </div>
    {% endif %}

    <button class="btn btn-primary" id="analyze-btn" onclick="startAnalysis()">
      <span>ğŸš€</span> å¼€å§‹åˆ†æ
    </button>
  </div>

  <!-- progress -->
  <div class="card" id="progress-section">
    <div class="section-label">å¤„ç†è¿›åº¦</div>
    <div class="steps">
      <div class="step" id="step-fetch">
        <div class="step-icon">ğŸ“¡</div>
        <div class="step-body">
          <div class="step-name">è·å–è§†é¢‘ä¿¡æ¯</div>
          <div class="step-msg" id="msg-fetch">â€”</div>
        </div>
      </div>
      <div class="step" id="step-transcript">
        <div class="step-icon">ğŸ“</div>
        <div class="step-body">
          <div class="step-name">æå–å­—å¹• / è¯­éŸ³è½¬å½•</div>
          <div class="step-msg" id="msg-transcript">â€”</div>
        </div>
      </div>
      <div class="step" id="step-frames">
        <div class="step-icon">ğŸ–¼</div>
        <div class="step-body">
          <div class="step-name">æå–å…³é”®å¸§</div>
          <div class="step-msg" id="msg-frames">â€”</div>
        </div>
      </div>
      <div class="step" id="step-analyze">
        <div class="step-icon">ğŸ¤–</div>
        <div class="step-body">
          <div class="step-name">Claude AI åˆ†æ</div>
          <div class="step-msg" id="msg-analyze">â€”</div>
        </div>
      </div>
      <div class="step" id="step-output">
        <div class="step-icon">ğŸ’¾</div>
        <div class="step-body">
          <div class="step-name">ä¿å­˜æŠ¥å‘Š</div>
          <div class="step-msg" id="msg-output">â€”</div>
        </div>
      </div>
    </div>
    <div class="error-box" id="error-box">
      <strong>å‡ºé”™äº†</strong>
      <div id="error-msg"></div>
      <pre id="error-detail" style="display:none"></pre>
    </div>
  </div>

  <!-- result -->
  <div id="result-section">

    <!-- video header -->
    <div class="card">
      <div class="video-header">
        <img class="video-thumb" id="res-thumb" src="" alt="thumbnail">
        <div class="video-meta">
          <div class="video-title" id="res-title"></div>
          <div class="video-info">
            <span id="res-channel"></span>
            <span id="res-duration"></span>
            <a id="res-link" href="#" target="_blank">â–¶ åœ¨ YouTube è§‚çœ‹</a>
          </div>
        </div>
      </div>
    </div>

    <!-- overview -->
    <div class="card">
      <div class="section-label">å†…å®¹æ¦‚è¿°</div>
      <div class="overview-text" id="res-overview"></div>
    </div>

    <!-- core structure diagram â€” rough.js Excalidraw-style canvas -->
    <div class="card" id="diagram-card" style="display:none">
      <div class="diagram-card-hdr">
        <div class="section-label">æ ¸å¿ƒç»“æ„</div>
        <button class="btn-expand" onclick="openDiagramModal()">â›¶ å±•å¼€æµè§ˆ</button>
      </div>
      <div class="diagram-wrap" onclick="openDiagramModal()" style="cursor:pointer" title="ç‚¹å‡»å±•å¼€å…¨å›¾">
        <canvas id="res-diagram-canvas"></canvas>
        <p style="text-align:center;font-size:11px;color:#b09060;margin-top:6px;margin-bottom:0">ç¼©ç•¥å›¾ Â· ç‚¹å‡»å±•å¼€æŸ¥çœ‹å…¨å›¾</p>
      </div>
    </div>

    <!-- chapters -->
    <div class="card">
      <div class="section-label">ç« èŠ‚è¯¦æƒ…</div>
      <div class="chapters" id="res-chapters"></div>
    </div>

    <!-- action bar -->
    <div class="action-bar">
      <button class="btn btn-outline" onclick="downloadJSON()">â¬‡ ä¸‹è½½ JSON</button>
      <button class="btn btn-outline" onclick="resetForm()">ğŸ”„ åˆ†ææ–°è§†é¢‘</button>
    </div>

  </div>

</div>

<!-- core structure diagram â€” full-screen modal with pan/zoom -->
<div id="diagram-modal">
  <div id="diagram-modal-bg" onclick="closeDiagramModal()"></div>
  <div id="diagram-modal-inner">
    <div id="diagram-modal-hdr">
      <span class="modal-title">æ ¸å¿ƒç»“æ„</span>
      <div style="display:flex;align-items:center;gap:14px">
        <span class="modal-hint">æ‹–åŠ¨å¹³ç§» Â· æ»šè½®ç¼©æ”¾ Â· Esc å…³é—­</span>
        <button class="modal-close" onclick="closeDiagramModal()">âœ•</button>
      </div>
    </div>
    <div id="diagram-modal-body">
      <canvas id="diagram-modal-canvas"></canvas>
    </div>
    <div id="diagram-modal-footer">åŒæŒ‡æåˆç¼©æ”¾ï¼ˆè§¦å±ï¼‰</div>
  </div>
</div>

<script>
// â”€â”€ state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SERVER_HAS_KEY = {{ server_has_key | tojson }};
let _lastResult = null;
let _currentDiagramData = null;

// â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function $(id) { return document.getElementById(id); }

function setStep(name, status, message) {
  const el = $(`step-${name}`);
  if (!el) return;
  el.className = `step ${status}`;
  const icons = { active: 'â³', done: 'âœ“', warn: 'âš ', skip: 'â€”', error: 'âœ—' };
  el.querySelector('.step-icon').textContent = icons[status] || 'â—‹';
  if (message) $(`msg-${name}`).textContent = message;
}

function showError(msg, detail) {
  const box = $('error-box');
  box.style.display = 'block';
  $('error-msg').textContent = msg;
  if (detail) {
    $('error-detail').textContent = detail;
    $('error-detail').style.display = 'block';
  }
  $('analyze-btn').disabled = false;
  $('analyze-btn').textContent = 'ğŸ”„ é‡è¯•';
}

// â”€â”€ Diagram core renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Renders diagram onto `canvas` at `drawW` CSS-pixel width.
// Sets canvas.width/height (physical) and canvas.style.width/height (CSS px).
function _renderDiagram(diagramData, canvas, drawW) {
  const nodes = diagramData.nodes || [];
  const edges = diagramData.edges || [];
  if (!nodes.length) return;

  const dpr = window.devicePixelRatio || 1;
  const W = drawW;

  // â”€â”€ Monet-inspired palette â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const iMaxW = Math.min(W * 0.27, 195);
  const STYLES = {
    core: {
      font: 'bold 17px Caveat, sans-serif', lineH: 23, padX: 20, padY: 15,
      minW: 200, maxW: Math.min(W * 0.44, 300),
      fill: '#fef3c7', stroke: '#d97706', strokeW: 2.5, roughness: 1.5, textColor: '#78350f',
    },
    phase: {
      font: '700 15px Caveat, sans-serif', lineH: 20, padX: 14, padY: 11,
      minW: 115, maxW: Math.min(W * 0.24, 175),
      fill: '#e0f2fe', stroke: '#0284c7', strokeW: 2.0, roughness: 1.3, textColor: '#0c4a6e',
    },
    insight: {
      font: '14px Caveat, sans-serif', lineH: 18, padX: 12, padY: 10,
      minW: 120, maxW: iMaxW,
      fill: '#fdf4ff', stroke: '#a855f7', strokeW: 1.5, roughness: 1.2, textColor: '#581c87',
    },
  };

  // â”€â”€ CJK-aware text width â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const _mc = document.createElement('canvas').getContext('2d');

  function parseFontSize(fontStr) {
    const m = fontStr.match(/(\d+(?:\.\d+)?)px/);
    return m ? +m[1] : 16;
  }

  function textW(str, font) {
    _mc.font = font;
    const measured = _mc.measureText(str).width;
    const fs = parseFontSize(font);
    const cjk = (str.match(/[\u4e00-\u9fff\u3040-\u30ff\uac00-\ud7af\uff00-\uffef]/g) || []).length;
    const minW = cjk * fs * 0.97 + (str.length - cjk) * fs * 0.56;
    return Math.max(measured, minW);
  }

  function wrapText(text, font, maxW) {
    const parts = text.split(' ');
    const lines = [];
    let cur = '';
    for (const p of parts) {
      const test = cur ? cur + ' ' + p : p;
      if (textW(test, font) > maxW && cur) { lines.push(cur); cur = p; }
      else cur = test;
    }
    if (cur) lines.push(cur);
    // Secondary char-level split for long CJK runs
    const out = [];
    for (const ln of lines) {
      if (textW(ln, font) <= maxW * 1.05) { out.push(ln); continue; }
      let seg = '';
      for (const ch of ln) {
        if (textW(seg + ch, font) > maxW && seg) { out.push(seg); seg = ch; }
        else seg += ch;
      }
      if (seg) out.push(seg);
    }
    return out.length ? out : [text.slice(0, 10) + 'â€¦'];
  }

  // â”€â”€ Build graph maps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const children = {};
  nodes.forEach(n => children[n.id] = []);
  edges.forEach(e => { if (children[e.from] !== undefined) children[e.from].push(e.to); });
  const root = nodes.find(n => n.type === 'core');
  if (!root) return;

  // â”€â”€ Compute node dimensions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const dims = {};
  nodes.forEach(n => {
    const s = STYLES[n.type] || STYLES.insight;
    const maxTW = s.maxW - s.padX * 2;
    const lines = wrapText(n.label, s.font, maxTW);
    const measuredW = lines.reduce((m, l) => Math.max(m, textW(l, s.font)), 0);
    const w = Math.max(s.minW, Math.min(s.maxW, measuredW + s.padX * 2 + 6));
    const h = s.padY * 2 + lines.length * s.lineH;
    dims[n.id] = { w, h, lines, style: s };
  });

  // â”€â”€ Radial layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Root at center. Phase nodes at R1 (inner ring). Insight nodes branch
  // outward from their parent phase along the radial direction, spread
  // perpendicular to it â€” this keeps each branch self-contained and
  // prevents overlap between branches.
  const phaseIds = children[root.id] || [];
  const pCount = Math.max(phaseIds.length, 1);

  // Scale radii to W so the modal (wide) spreads nicely and the card fits
  const R1 = Math.min(W * 0.165, 165);
  const R2 = Math.min(W * 0.36, 300);
  const cX = W / 2;
  const cY = R2 + (dims[root.id]?.h || 60) / 2 + 30;
  const pos = {};
  const rd = dims[root.id];
  pos[root.id] = { x: cX - rd.w / 2, y: cY - rd.h / 2 };

  // Border-exit point: where a line from node-center toward (tx,ty) exits its border
  function exitPt(p, d, tx, ty) {
    const ncx = p.x + d.w / 2, ncy = p.y + d.h / 2;
    const dx = tx - ncx, dy = ty - ncy;
    if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) return { x: ncx, y: ncy };
    const hw = d.w / 2 + 1, hh = d.h / 2 + 1;
    const tx_ = dx ? Math.abs(hw / dx) : Infinity;
    const ty_ = dy ? Math.abs(hh / dy) : Infinity;
    const t = Math.min(tx_, ty_);
    return { x: ncx + dx * t, y: ncy + dy * t };
  }

  // Half-extent of a box along the radial direction (cosA, sinA).
  // = projection of the box semi-axes onto the radial unit vector.
  // This is the exact distance from box center to the box edge in that direction.
  function radHalf(d, cosA, sinA) {
    return d.w / 2 * cosA + d.h / 2 * sinA;
  }

  phaseIds.forEach((pid, pi) => {
    const pAngle = -Math.PI / 2 + (2 * Math.PI * pi / pCount);
    const cosA = Math.abs(Math.cos(pAngle));
    const sinA = Math.abs(Math.sin(pAngle));
    const rdx  = Math.cos(pAngle);
    const rdy  = Math.sin(pAngle);
    const pd   = dims[pid];
    const pCX  = cX + R1 * rdx;
    const pCY  = cY + R1 * rdy;
    pos[pid] = { x: pCX - pd.w / 2, y: pCY - pd.h / 2 };

    const iIds = children[pid] || [];
    if (!iIds.length) return;

    // Stack insight nodes outward along the radial direction, one after another.
    // curR = current "outer edge" distance along the radial from the phase center.
    // Start just past the phase node's own radial half-extent + gap.
    let curR = radHalf(pd, cosA, sinA) + 14;

    iIds.forEach((iid) => {
      const id_ = dims[iid];
      const rh = radHalf(id_, cosA, sinA);  // half-extent of this insight
      const centerR = curR + rh;             // insight center along radial
      pos[iid] = {
        x: pCX + rdx * centerR - id_.w / 2,
        y: pCY + rdy * centerR - id_.h / 2,
      };
      curR = centerR + rh + 16;             // advance past insight + gap
    });
  });

  // â”€â”€ Bounding-box: measure actual extent of every placed node â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Then shift the whole diagram so every node has â‰¥ PAD margin on all sides,
  // and let the canvas grow beyond W if needed (modal can pan; thumbnail scales).
  const PAD = 24;
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  nodes.forEach(n => {
    const p = pos[n.id]; if (!p) return;
    const d = dims[n.id];
    if (p.x       < minX) minX = p.x;
    if (p.x + d.w > maxX) maxX = p.x + d.w;
    if (p.y       < minY) minY = p.y;
    if (p.y + d.h > maxY) maxY = p.y + d.h;
  });
  const shiftX = minX < PAD ? PAD - minX : 0;
  const shiftY = minY < PAD ? PAD - minY : 0;
  if (shiftX > 0 || shiftY > 0) {
    Object.keys(pos).forEach(id => {
      if (!pos[id]) return;
      pos[id].x += shiftX;
      pos[id].y += shiftY;
    });
  }
  const actualW = maxX + shiftX + PAD;   // may exceed W if branches are deep
  const canvasH = maxY + shiftY + PAD;

  // â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  canvas.width  = Math.round(actualW * dpr);
  canvas.height = Math.round(canvasH * dpr);
  canvas.style.width  = actualW + 'px';
  canvas.style.height = canvasH + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const rc = rough.canvas(canvas);

  // â”€â”€ Draw edges (below nodes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  edges.forEach((edge, ei) => {
    const fp = pos[edge.from], tp = pos[edge.to];
    if (!fp || !tp) return;
    const fd = dims[edge.from], td = dims[edge.to];
    const tcX = tp.x + td.w / 2, tcY = tp.y + td.h / 2;
    const fcX = fp.x + fd.w / 2, fcY = fp.y + fd.h / 2;
    const ep1 = exitPt(fp, fd, tcX, tcY);
    const ep2 = exitPt(tp, td, fcX, fcY);

    rc.line(ep1.x, ep1.y, ep2.x, ep2.y, {
      roughness: 1.2, stroke: '#94a3b8', strokeWidth: 1.7, seed: ei * 7 + 1,
    });
    // Arrowhead at ep2
    const ang = Math.atan2(ep2.y - ep1.y, ep2.x - ep1.x);
    const al = 9, aa = 0.42;
    rc.line(ep2.x, ep2.y, ep2.x - al * Math.cos(ang - aa), ep2.y - al * Math.sin(ang - aa),
      { roughness: 0.7, stroke: '#94a3b8', strokeWidth: 1.5, seed: ei * 7 + 2 });
    rc.line(ep2.x, ep2.y, ep2.x - al * Math.cos(ang + aa), ep2.y - al * Math.sin(ang + aa),
      { roughness: 0.7, stroke: '#94a3b8', strokeWidth: 1.5, seed: ei * 7 + 3 });
  });

  // â”€â”€ Draw nodes (over edges) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  nodes.forEach((n, ni) => {
    const p = pos[n.id];
    const d = dims[n.id];
    const s = d.style;
    if (!p) return;

    rc.rectangle(p.x, p.y, d.w, d.h, {
      roughness: s.roughness, fill: s.fill, fillStyle: 'solid',
      stroke: s.stroke, strokeWidth: s.strokeW, seed: ni * 13 + 5,
    });

    ctx.font = s.font;
    ctx.fillStyle = s.textColor;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const ncx = p.x + d.w / 2;
    const tH = d.lines.length * s.lineH;
    const ty = p.y + (d.h - tH) / 2;
    d.lines.forEach((line, li) => ctx.fillText(line, ncx, ty + li * s.lineH));
  });
}

// â”€â”€ In-card render wrapper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Always render at VIRT_W=1400 so layout never overlaps, then scale down
// as a thumbnail for the card. The same offscreen is reused for the modal.
const _VIRT_W = 1400;

function renderExcalidrawDiagram(diagramData) {
  // Render at virtual width and cache as offscreen (once per result)
  if (!_modalOffscreen) {
    const off = document.createElement('canvas');
    _renderDiagram(diagramData, off, _VIRT_W);
    _modalOffscreen = off;
  }
  // Draw scaled thumbnail into card canvas
  const canvas = $('res-diagram-canvas');
  const wrap = canvas.parentElement;
  const W = Math.max((wrap.clientWidth || 0) - 40, 400);
  const offW = parseFloat(_modalOffscreen.style.width)  || _VIRT_W;
  const offH = parseFloat(_modalOffscreen.style.height) || 800;
  const H = offH * W / offW;   // scale proportionally from actual canvas size
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  ctx.fillStyle = '#fffdf5';
  ctx.fillRect(0, 0, W, H);
  ctx.drawImage(_modalOffscreen, 0, 0, W, H);
}

// â”€â”€ Diagram modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const _modal = { panX: 0, panY: 0, zoom: 1, dragging: false, lastX: 0, lastY: 0 };
let _modalOffscreen = null;
let _modalTouchState = null;

function openDiagramModal() {
  if (!_currentDiagramData) return;

  $('diagram-modal').style.display = 'flex';
  document.body.style.overflow = 'hidden';

  // Reuse the offscreen already rendered by renderExcalidrawDiagram;
  // if somehow missing (e.g., modal opened before card rendered), create it.
  if (!_modalOffscreen) {
    const off = document.createElement('canvas');
    _renderDiagram(_currentDiagramData, off, _VIRT_W);
    _modalOffscreen = off;
  }

  // RAF: let the flex layout settle before reading dimensions
  requestAnimationFrame(() => {
    const body = $('diagram-modal-body');
    const MW = body.clientWidth  || (window.innerWidth  - 48);
    const MH = body.clientHeight || (window.innerHeight - 120);
    const dpr = window.devicePixelRatio || 1;
    const mc = $('diagram-modal-canvas');
    mc.width  = Math.round(MW * dpr);
    mc.height = Math.round(MH * dpr);
    mc.style.width  = MW + 'px';
    mc.style.height = MH + 'px';

    const offW = parseFloat(_modalOffscreen.style.width)  || _VIRT_W;
    const offH = parseFloat(_modalOffscreen.style.height) || (_modalOffscreen.height / dpr);

    // Initial zoom: fit diagram inside modal with padding
    _modal.zoom = Math.min((MW - 40) / offW, (MH - 40) / offH, 1);
    _modal.panX = (MW - offW * _modal.zoom) / 2;
    _modal.panY = 20;

    _drawModal();
    _attachModalEvents();
  });
}

function closeDiagramModal() {
  $('diagram-modal').style.display = 'none';
  document.body.style.overflow = '';
  _detachModalEvents();
}

function _drawModal() {
  const mc = $('diagram-modal-canvas');
  if (!mc || !_modalOffscreen) return;
  const dpr = window.devicePixelRatio || 1;
  const MW = parseInt(mc.style.width);
  const MH = parseInt(mc.style.height);
  const offW = parseFloat(_modalOffscreen.style.width)  || (_modalOffscreen.width  / dpr);
  const offH = parseFloat(_modalOffscreen.style.height) || (_modalOffscreen.height / dpr);

  const ctx = mc.getContext('2d');
  ctx.clearRect(0, 0, mc.width, mc.height);
  ctx.save();
  ctx.scale(dpr, dpr);
  // Parchment background
  ctx.fillStyle = '#faf9f4';
  ctx.fillRect(0, 0, MW, MH);
  // Draw offscreen diagram at current pan/zoom
  ctx.drawImage(_modalOffscreen, _modal.panX, _modal.panY,
                offW * _modal.zoom, offH * _modal.zoom);
  ctx.restore();
}

// â”€â”€ Modal event handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _onMD(e) {
  _modal.dragging = true;
  _modal.lastX = e.clientX; _modal.lastY = e.clientY;
  $('diagram-modal-canvas').style.cursor = 'grabbing';
}
function _onMM(e) {
  if (!_modal.dragging) return;
  _modal.panX += e.clientX - _modal.lastX;
  _modal.panY += e.clientY - _modal.lastY;
  _modal.lastX = e.clientX; _modal.lastY = e.clientY;
  _drawModal();
}
function _onMU() {
  _modal.dragging = false;
  const mc = $('diagram-modal-canvas');
  if (mc) mc.style.cursor = 'grab';
}
function _onMW(e) {
  e.preventDefault();
  const f = e.deltaY < 0 ? 1.12 : (1 / 1.12);
  const newZ = Math.max(0.15, Math.min(6, _modal.zoom * f));
  const mc = $('diagram-modal-canvas');
  const rect = mc.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  _modal.panX = mx - (mx - _modal.panX) * (newZ / _modal.zoom);
  _modal.panY = my - (my - _modal.panY) * (newZ / _modal.zoom);
  _modal.zoom = newZ;
  _drawModal();
}
function _onTS(e) {
  e.preventDefault();
  if (e.touches.length === 1) {
    _modal.dragging = true;
    _modal.lastX = e.touches[0].clientX; _modal.lastY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    _modal.dragging = false;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    _modalTouchState = { dist: Math.hypot(dx, dy), zoom0: _modal.zoom };
  }
}
function _onTM(e) {
  e.preventDefault();
  if (e.touches.length === 1 && _modal.dragging) {
    _modal.panX += e.touches[0].clientX - _modal.lastX;
    _modal.panY += e.touches[0].clientY - _modal.lastY;
    _modal.lastX = e.touches[0].clientX; _modal.lastY = e.touches[0].clientY;
    _drawModal();
  } else if (e.touches.length === 2 && _modalTouchState) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    _modal.zoom = Math.max(0.15, Math.min(6,
      _modalTouchState.zoom0 * Math.hypot(dx, dy) / _modalTouchState.dist));
    _drawModal();
  }
}
function _onTE() { _modal.dragging = false; _modalTouchState = null; }

function _attachModalEvents() {
  const mc = $('diagram-modal-canvas');
  if (!mc) return;
  mc.addEventListener('mousedown', _onMD);
  mc.addEventListener('mousemove', _onMM);
  window.addEventListener('mouseup', _onMU);
  mc.addEventListener('wheel', _onMW, { passive: false });
  mc.addEventListener('touchstart', _onTS, { passive: false });
  mc.addEventListener('touchmove',  _onTM, { passive: false });
  mc.addEventListener('touchend',   _onTE);
}
function _detachModalEvents() {
  const mc = $('diagram-modal-canvas');
  if (!mc) return;
  mc.removeEventListener('mousedown', _onMD);
  mc.removeEventListener('mousemove', _onMM);
  window.removeEventListener('mouseup', _onMU);
  mc.removeEventListener('wheel', _onMW);
  mc.removeEventListener('touchstart', _onTS);
  mc.removeEventListener('touchmove',  _onTM);
  mc.removeEventListener('touchend',   _onTE);
}

// Esc closes modal
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && $('diagram-modal').style.display !== 'none') closeDiagramModal();
});

// â”€â”€ analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function startAnalysis() {
  const url = $('url-input').value.trim();
  if (!url) { $('url-input').focus(); return; }

  const apiKey = SERVER_HAS_KEY ? '' : ($('api-key-input')?.value.trim() || '');
  if (!SERVER_HAS_KEY && !apiKey) {
    $('api-key-input').focus();
    $('api-key-input').style.borderColor = 'var(--error)';
    return;
  }

  const maxFrames = parseInt($('frames-select').value);
  const lang = $('lang-select').value;

  // reset UI
  $('analyze-btn').disabled = true;
  $('analyze-btn').innerHTML = '<span style="animation:spin 1s linear infinite;display:inline-block">â³</span> åˆ†æä¸­â€¦';
  $('progress-section').style.display = 'block';
  $('result-section').style.display = 'none';
  $('error-box').style.display = 'none';
  $('error-detail').style.display = 'none';
  ['fetch','transcript','frames','analyze','output'].forEach(s => setStep(s,'pending','â€”'));

  // POST to start job
  let jobId;
  try {
    const res = await fetch('/api/analyze', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url, lang, api_key: apiKey, max_frames: maxFrames, no_frames: maxFrames === 0 }),
    });
    const data = await res.json();
    if (!res.ok) { showError(data.error || 'è¯·æ±‚å¤±è´¥'); return; }
    jobId = data.job_id;
  } catch(e) {
    showError('æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨: ' + e.message);
    return;
  }

  // Stream SSE events
  const es = new EventSource(`/api/stream/${jobId}`);
  es.onmessage = (e) => {
    const msg = JSON.parse(e.data);

    if (msg.type === 'step') {
      setStep(msg.step, msg.status, msg.message);

    } else if (msg.type === 'result') {
      es.close();
      _lastResult = msg.data;
      renderResult(msg.data);
      $('analyze-btn').disabled = false;
      $('analyze-btn').innerHTML = 'ğŸš€ å¼€å§‹åˆ†æ';

    } else if (msg.type === 'error') {
      es.close();
      showError(msg.message, msg.detail);

    } else if (msg.type === 'done') {
      es.close();
    }
  };
  es.onerror = () => {
    es.close();
    if (!_lastResult) showError('è¿æ¥ä¸­æ–­ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
  };
}

// â”€â”€ render result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderResult(data) {
  // header
  $('res-thumb').src = data.thumbnail_url;
  $('res-title').textContent = data.title;
  $('res-channel').textContent = 'ğŸ“º ' + data.channel;
  $('res-duration').textContent = 'â± ' + data.duration_str;
  $('res-link').href = data.youtube_url;

  // overview
  $('res-overview').textContent = data.overview;

  // chapters
  const ch = $('res-chapters');
  ch.innerHTML = '';
  (data.chapters || []).forEach((c) => {
    const ytLink = `https://www.youtube.com/watch?v=${data.video_id}&t=${Math.floor(c.start_seconds)}s`;
    const frameHtml = c.frame_url
      ? `<img src="${c.frame_url}" alt="${c.title}" loading="lazy" onerror="this.parentElement.innerHTML='<div class=no-frame>ğŸ–¼</div>'">`
      : `<div class="no-frame">ğŸ–¼</div>`;

    ch.innerHTML += `
      <div class="chapter-card">
        <div class="chapter-frame">${frameHtml}</div>
        <div class="chapter-body">
          <span class="chapter-ts">${c.timestamp}</span>
          <div class="chapter-title">
            <a href="${ytLink}" target="_blank" style="color:var(--text);text-decoration:none"
               onmouseover="this.style.color='var(--primary)'" onmouseout="this.style.color='var(--text)'">
              ${c.title}
            </a>
          </div>
          <div class="chapter-summary">${c.summary}</div>
        </div>
      </div>`;
  });

  // Show result section FIRST so clientWidth is available for canvas sizing
  $('result-section').style.display = 'block';
  $('result-section').scrollIntoView({ behavior: 'smooth', block: 'start' });

  // Diagram: show card, then double-RAF so layout is fully settled before measuring
  const dd = data.diagram_data;
  if (dd && dd.nodes && dd.nodes.length) {
    _currentDiagramData = dd;
    _modalOffscreen = null;  // invalidate cached offscreen on new result
    $('diagram-card').style.display = 'block';
    requestAnimationFrame(() => requestAnimationFrame(() => renderExcalidrawDiagram(dd)));
  }
}

// â”€â”€ utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function downloadJSON() {
  if (!_lastResult) return;
  const blob = new Blob([JSON.stringify(_lastResult, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `${_lastResult.video_id || 'summary'}.json`;
  a.click();
}

function resetForm() {
  $('url-input').value = '';
  $('progress-section').style.display = 'none';
  $('result-section').style.display = 'none';
  $('diagram-card').style.display = 'none';
  $('error-box').style.display = 'none';
  $('analyze-btn').disabled = false;
  $('analyze-btn').innerHTML = 'ğŸš€ å¼€å§‹åˆ†æ';
  _lastResult = null;
  _currentDiagramData = null;
  _modalOffscreen = null;
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Enter key submits
$('url-input').addEventListener('keydown', e => { if (e.key === 'Enter') startAnalysis(); });

// CSS spin keyframe
const style = document.createElement('style');
style.textContent = '@keyframes spin { to { transform: rotate(360deg); } }';
document.head.appendChild(style);
</script>
</body>
</html>
